`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2024/07/23 15:09:55
// Design Name: 
// Module Name: sram
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module sram(
input wire clk,
input wire rst,
input wire ce_n,
input wire oe_n,
input wire we_n,
input wire [3:0] bsel_n,
input wire [19:0] addr,
inout wire [31:0] data_bus
    );
    
reg [31:0] regs[255:0];
integer i;
//inout信号作为输入信号
wire [31:0] in_data;
reg [31:0] out_data;
assign in_data =  (we_n==1'b0) ?data_bus: 32'hz;
//inout信号作为输出信号
assign  data_bus = (oe_n==1'b0) ? out_data : 32'hz;
//WRITE
always @(posedge clk , posedge rst) begin
    if(rst==1'b1) begin
   
regs[0] <= 32'h0280040C;
regs[1] <= 32'h0280040D;
regs[2] <= 32'h15008004;
regs[3]<= 32'h02840085;
regs[4] <= 32'h0010358E;
regs[5] <= 32'h028001AC;
regs[6] <= 32'h028001CD;
regs[7] <= 32'h2980008E;
regs[8] <= 32'h2880008F;
regs[9] <= 32'h5C000DCF;
regs[10] <= 32'h02801084;
regs[11] <= 32'h5FFFE485;
regs[12] <= 32'h5C000080;
   /* regs[0]=32'b0010_1000_10_0000_0001_1000_10000_00001;
   regs[1]=32'b0010_1000_10_0000_0001_1100_10000_00010; 
   regs[2]=32'b0010_1000_10_0000_0001_0100_10000_00011;
    regs[3]=32'b0010_1001_10_0000_0000_0100_10000_00011;
    regs[4]=32'b0110_01_1111_1111_1111_1100_00001_00010;
     regs[5]=32'b0010_1000_10_0000_0001_1100_10000_00001;
    regs[6]=32'd5;
    regs[7]=32'd4;*/
    //实验1 
    /*
   regs[0]=32'h0280040c;//32'b0010_1000_10_0000_0000_0100_10000_00001;
   regs[1]=32'h0280040d;//32'b0010_1000_10_0000_0000_1000_10000_00010;
   regs[2]=32'h15008004;//32'b0000_0000_0001_0000_0_00001_00010_00011;
   regs[3]=32'h02840085;//32'b0000_0000_0001_0000_0_00001_00010_00100;
   regs[4]=32'h0010358e;//32'b0000_0000_0001_0000_0_00001_00010_00101;
   regs[5]=32'h028001ac;//32'b0110_01_1111_1111_1111_1100_00001_00010;  //BGE
  */
    /* 实验2
       regs[0]=32'b0010_1000_10_0000_0000_0100_10000_00001;
       regs[1]=32'b0010_1000_10_0000_0000_1000_10000_00010;
       regs[2]=32'b0000_0000_0001_0000_0_00001_00010_00011;
       regs[3]=32'b0010_1000_00_0000_0000_0100_11111_00100;  //查询r4
       regs[4]=32'b0000_0000_0001_0101_1_00001_00010_00011;
       regs[5]=32'b0000_0000_0001_0101_1_00001_00010_00011; 
       regs[6]=32'b0010_1001_10_0000_0000_0000_11111_00010; //发送
       regs[7]=32'b0000_0000_0001_0101_1_00001_00010_00011;
        regs[8]=32'b0000_0000_0001_0101_1_00001_00010_00011;
  regs[9]=32'b0010_1000_00_0000_0000_0100_11111_00100;  //查询r4
   for(i = 10; i < 100; i = i + 1) begin
       regs[i] <= 32'b0000_0000_0001_0101_1_00001_00010_00011;     
      end 
    regs[100]=32'b0010_1000_00_0000_0000_0100_11111_00100;  //查询r4
    regs[101]=32'b0000_0000_0001_0101_1_00001_00010_00011;
   regs[102]=32'b0000_0000_0001_0101_1_00001_00010_00011;
   regs[103]=32'b0010_1000_00_0000_0000_0000_11111_00101;  //接受到5
    regs[104]=32'b0000_0000_0001_0101_1_00001_00010_00011;
   regs[105]=32'b0110_01_1111_1111_1111_1010_00001_00010;
   
   
     regs[106]=32'b0010_1000_00_0000_0000_0100_11111_00100;  //查询r4
      for(i = 107; i < 200; i = i + 1) begin
       regs[i] <= 32'b0000_0000_0001_0101_1_00001_00010_00011;   
      end 
      regs[200]=32'b0010_1000_00_0000_0000_0100_11111_00100;  //查询r4
   regs[201]=32'b0000_0000_0001_0101_1_00001_00010_00011;
    regs[202]=32'b00000_0000_0001_0101_1_00001_00010_00011;
    regs[203]=32'b0010_1000_00_0000_0000_0000_11111_00101;  //接受到5
      for(i = 204; i < 256; i = i + 1) begin
      regs[i] <= 32'b0000_0000_0001_0101_1_00001_00010_00011;     
      end  */
      // regs[0]=32'b0010_1000_10_0000_0010_0000_10000_00010;  //LD.W ff00_f600;->reg2
     //  regs[1]=32'b0010_1000_10_0000_0010_0100_10000_00011;  //LD.W f500_00ff;-?REG3
     //  regs[2]=32'b0000_0000_0100_0000_1_00100_00010_00100; //slli
      //regs[3]=32'b0101_00_0000_0000_0000_0010_0000_0000_00; //
      //  regs[4]=32'b0000_0000_0100_0000_1_00100_00010_00101;  //slli
      //  regs[5]=32'b0000_0000_0100_0000_1_00100_00010_00110;  //slli
        //regs[2]=32'b0000_0000_0100_0100_1_00100_00001_00011; //srli
        //regs[2]=32'b0000_0000_0001_0100_1_00010_00001_00011; //AND reg1 &reg2->reg3
        //regs[2]=32'b0010_1001_10_0000_0000_1000_10000_11111; //ST.W ffff000f;->ex 2
        //regs[3]=32'b0010_1001_10_0000_0001_0000_10000_11111; //ST.W ffff000f;->ex 4
       //regs[0]=32'b0010_1000_00_0000_0010_0111_10000_00010;  //LD.B ,10_01第3个字节里的值放入rg2  5
       //regs[1]=32'b0010_1000_00_0000_0010_0001_10000_00001;  //LD.B ,10_00第1个字节的值放入rg1  6
       //regs[2]=32'b0000_0010_10_1111_1111_1110_00001_00011;  //addiw  6-2=4->reg3
       //regs[3]=32'b0010_1001_00_0000_0000_1001_10000_11111;   //STB将0f存在ex 02  第1个字节
       //regs[4]=32'b0010_1001_00_0000_0001_0010_10000_11111;   //STB将0f存在ex 04 第2个字节
     // regs[3]=32'b0110_01_0000_0000_0000_0010_00010_11111;  //BGE
       //regs[3]=32'b0101_10_0000_0000_0000_0010_00010_00001;  //beq
        //regs[3]=32'b0101_11_0000_0000_0000_0010_00001_00010;  //bne
       //regs[4]=32'b0000_0000_0001_0000_0_00001_00010_00101;     //addw 5+6=11->reg5
      // regs[4]=32'b0001_010_0000_0000_1000_0001_0000_00110;    //lu12i   00810000->reg6
       //regs[4]=32'b0001_110_1000_0000_0000_0001_0000_00110;  //pcadd  00010010 ->reg6
       //regs[4]=32'b0000_0000_0100_1000_1_00010_11111_00110; //SRAI ffffc003->reg6
      // regs[4]=32'b0000_0000_0001_0101_0_00001_00010_00101;    // OR 7->reg 5
       //regs[5]=32'b0000_0000_0001_0101_1_00001_00010_00110;    //XOR 3->reg 6
       //regs[4]=32'b0000_0011_10_1111_1111_0000_00010_00101;    // ORI 0000_.._0000_1111_1111_5->reg5
      // regs[5]=32'b0000_0011_01_0000_1111_1111_00010_00110;  //ANDI   5 ->reg6
     // regs[4]=32'b0000_0000_0100_1000_1_00010_00100_00110; //SRAI 2->reg6
      //regs[4]=32'b0000_0000_0100_1000_1_00010_00100_00110; //sltui 1>reg5
       //regs[5]=32'b0000_0010_01_0000_0000_0101_00010_00110;  //sltui 0>reg5
      //regs[0]=32'b0010_1000_10_0000_0010_0000_10000_00001; //00将地址baseream1000里的值放入rg1
      //regs[1]=32'b0010_1000_10_0000_0010_0100_10000_00010; //04将地址baseream80400000+1001里的值放入rg2
      //regs[2]=32'b0000_0000_0001_0000_0_00001_00010_00011;  //将rg1和rg2的值相加放在rg3
      // regs[3]=32'b0000_0000_0001_0000_0_00001_00010_00100;  //将rg1和rg2的值相加放在rg4
       //regs[4]=32'b0000_0000_0001_0000_0_00100_00011_00101;  //将rg4和rg3的值相加放在rg5
       //regs[5]=32'b0000_0000_0001_0000_0_00100_00011_00110;  //将rg4和rg3的值相加放在rg6
       // regs[6]=32'b0000_0000_0001_0000_0_00101_00110_00001;  //将rg5和rg6的值相加放在rg1
      //regs[2]=32'b0001_010_1111_1111_1111_1111_0001_00011; //lu21i
      //regs[2]=32'b0000_0000_0001_0000_0_00001_00010_00011; //08将rg1和rg2的值相加放在rg3
      //regs[3]=32'b0010_1001_10_0000_0010_1000_10001_00011;  //0C将rg3放入的值放入baseram1010里
     // regs[3]=32'b0010_1001_00_0000_0010_1011_10000_00011;         //将rg3放入的值放入extram1010里第3个字节
      
      //regs[4]=32'b0101_11_0000_0000_0000_0010_00001_00010; 
      //regs[4]=32'b0100_11_0000_0000_0000_0110_00000_00110;  //10 jirl 把14存在rg6，跳到18
      //regs[4]=32'b0101_11_0000_0000_0000_0010_00001_00010; //10如果rg1和rg2内容不等，则跳到mem[6]
    //  regs[5]=32'b0000_0000_0001_0101_0_00010_00001_00100; //14 rg1和rg2内容做或，存到rg4
     // regs[6]=32'b0000_0000_0001_0101_0_00010_00001_00101;  //18 rg1和rg2内容做或，存到rg5
     // regs[7]=32'b0101_00_1111_1111_1111_1011_11111_11111;   //1C
    
    
    for(i =13; i < 256; i = i + 1) begin
       regs[i] <= 32'h0;     
    end 
     
      out_data<=32'b0;   
    end
    else begin
        case ({ce_n,oe_n,we_n})
            3'b111,3'b110,3'b101,3'b100,3'b011,3'b000: begin
              out_data<=32'b0;    
            end
            3'b001:begin
                    if((bsel_n)==4'b1110||(bsel_n)==4'b1101 ||(bsel_n)==4'b1011 ||(bsel_n)==4'b0111||bsel_n==4'b0000) begin
                          out_data<=regs[addr[7:0]];
                    end
                    else begin
                          out_data<=32'b0;
                    end            
                end
            3'b010:begin
                 if(((bsel_n)==4'b1110||(bsel_n)==4'b1101 ||(bsel_n)==4'b1011 ||(bsel_n)==4'b0111)) begin
                    if((bsel_n)==4'b1110) regs[addr[7:0]][7:0]<=in_data[7:0];
                    else if((bsel_n)==4'b1101) regs[addr[7:0]][15:8]<=in_data[7:0];
                    else if((bsel_n)==4'b1011) regs[addr[7:0]][23:16]<=in_data[7:0];
                    else if ((bsel_n)==4'b0111) regs[addr[7:0]][31:24]<=in_data[7:0];
                 end
                 else  if(bsel_n==4'b0000) begin
                     regs[addr[7:0]]<=in_data;
                 end
                 else begin             
                 end
                 out_data<=32'b0;       
            end   
        endcase  
    end
end

endmodule
